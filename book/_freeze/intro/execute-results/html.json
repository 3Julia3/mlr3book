{
  "hash": "7b7efe8a06a2948fe5dabec20ed5b42c",
  "result": {
    "markdown": "# Introduction and Overview\n\n::: {.cell}\n\n:::\n\n\n\n\nThe [mlr3](https://mlr3.mlr-org.com) [@mlr3] package and ecosystem provide a generic, object-oriented, and extensible framework for [classification](#tasks), [regression](#tasks), [survival analysis](#survival), and other machine learning tasks for the R language [@R].\nThis unified interface provides functionality to extend and combine existing [learners](#learners), intelligently select and tune the most appropriate technique for a [task](#tasks), and perform large-scale comparisons that enable meta-learning.\nExamples of this advanced functionality include [hyperparameter tuning](#tuning) and [feature selection](#fs).\n[Parallelization](#parallelization) of many operations is natively supported.\n\n:::{.callout-note}\nWe do not implement any [learners](#learners) ourselves, but provide a unified interface to many existing learners in R.\n:::\n\n## Target Audience\n\nWe expect that users of [mlr3](https://mlr3.mlr-org.com) have at least basic knowledge of machine learning and R.\nThe later chapters of this book describe advanced functionality that requires more advanced knowledge of both.\n[mlr3](https://mlr3.mlr-org.com) is suitable for complex projects that use advanced functionality as well as one-liners to quickly prototype specific tasks.\n\n[mlr3](https://mlr3.mlr-org.com) provides a domain-specific language for machine learning in R.\nWe target both **practitioners** who want to quickly apply machine learning algorithms and **researchers** who want to implement, benchmark, and compare their new methods in a structured environment.\n\n:::{.callout-note}\nThe package is a rewrite of an earlier version of [mlr](https://mlr.mlr-org.com) that leverages many years of experience to provide a state-of-the-art system that is easy to use and extend.\n:::\n\n## Why a Rewrite?\n\n[mlr](https://mlr.mlr-org.com) [@mlr] was first released to [CRAN](https://cran.r-project.org) in 2013, with the core design and architecture dating back much further.\nOver time, the addition of many features has led to a considerably more complex design that made it harder to build, maintain, and extend than we had hoped for.\nWith hindsight, we saw that some design and architecture choices in [mlr](https://mlr.mlr-org.com) made it difficult to support new features, in particular with respect to pipelines.\nFurthermore, the R ecosystem as well as helpful packages such as [data.table](https://cran.r-project.org/package=data.table) have undergone major changes in the meantime.\n\nIt would have been nearly impossible to integrate all of these changes into the original design of [mlr](https://mlr.mlr-org.com).\nInstead, we decided to start working on a reimplementation in 2018, which resulted in the first release of [mlr3](https://mlr3.mlr-org.com) on CRAN in July 2019.\nThe new design and the integration of further and newly-developed R packages (especially [R6](https://cran.r-project.org/package=R6), [future](https://cran.r-project.org/package=future), and [data.table](https://cran.r-project.org/package=data.table)) makes [mlr3](https://mlr3.mlr-org.com) much easier to use, maintain, and in many regards more efficient compared to its predecessor [mlr](https://mlr.mlr-org.com).\n\n## Design Principles\n\nWe follow these general design principles in the [mlr3](https://mlr3.mlr-org.com) package and ecosystem.\n\n* **Backend over frontend**.\n  Most packages of the [mlr3](https://mlr3.mlr-org.com) ecosystem focus on processing and transforming data, applying machine learning algorithms, and computing results.\n  Our core packages do not provide a graphical user interfaces (GUIs) whose dependencies would make an installation on a computing server unnecessarily tedious; visualizations of data and results are provided in extra packages like [mlr3viz](https://mlr3viz.mlr-org.com). [mlr3shiny](https://cran.r-project.org/package=mlr3shiny) provides an interface for some basic machine learning tasks using the [shiny](https://cran.r-project.org/package=shiny) package.\n* **Object orientation**. Embrace [R6](https://cran.r-project.org/package=R6) for a clean, object-oriented design, object state-changes, and reference semantics.\n* **Tabular data**. Embrace [data.table](https://cran.r-project.org/package=data.table) for fast and convenient computations on tabular data.\n* **Unify container and result classes** as much as possible and provide result data in `data.table`s.\n    This considerably simplifies the API and allows easy selection and \"split-apply-combine\" (aggregation) operations.\n    We combine `data.table` and `R6` to place references to non-atomic and compound objects in tables and make heavy use of list columns.\n* **Defensive programming and type safety**.\n  All user input is checked with [`checkmate`](https://cran.r-project.org/package=checkmate) [@checkmate].\n  Return types are documented, and mechanisms popular in base R which \"simplify\" the result unpredictably (e.g., `sapply()` or the `drop` argument for indexing data.frames) are avoided.\n* **Be light on dependencies**.\n  One of the main maintenance burdens for [mlr](https://mlr.mlr-org.com) was to keep up with changing learner interfaces and behavior of the many packages it depended on.\n  We require far fewer packages in [mlr3](https://mlr3.mlr-org.com) to make installation and maintenance easier.\n\n## Package Ecosystem\n\n[mlr3](https://mlr3.mlr-org.com) builds upon the following packages not developed by core members of the [mlr3](https://mlr3.mlr-org.com) team:\n\n  * [R6](https://cran.r-project.org/package=R6):\n    Reference class objects.\n  * [data.table](https://cran.r-project.org/package=data.table):\n    Extension of R's `data.frame`.\n  * [digest](https://cran.r-project.org/package=digest):\n    Hash digests.\n  * [uuid](https://cran.r-project.org/package=uuid):\n    Unique string identifiers.\n  * [lgr](https://cran.r-project.org/package=lgr):\n    Logging facility.\n  * [mlbench](https://cran.r-project.org/package=mlbench):\n    A collection of machine learning data sets.\n  * [evaluate](https://cran.r-project.org/package=evaluate):\n    For [capturing output, warnings, and exceptions](#error-handling).\n  * [future](https://cran.r-project.org/package=future) / [future.apply](https://cran.r-project.org/package=future.apply):\n    For [parallelization](#parallelization).\n\nAll these packages are well curated and mature; we expect no problems with dependencies.\n\nThe [mlr3](https://mlr3.mlr-org.com) package itself provides the base functionality that the rest of ecosystem rely on and some fundamental building blocks for machine learning.\nThe following packages extend [mlr3](https://mlr3.mlr-org.com) with capabilities for preprocessing, pipelining, visualizations, additional learners, additional task types, and more:\n\n\n::: {.cell layout-align=\"center\" hash='intro_cache/html/intro-001_13cd826f449fe8e20fafb140aa19373e'}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/mlr-org/mlr3/master/man/figures/mlr3verse.svg){fig-align='center' width=98%}\n:::\n:::\n\n\n\n\n:::{.callout-tip}\nA complete list with links to the repositories for the respective packages can be found on our [package overview](https://mlr-org.com/packages.html).\n:::\n\n\nWe build upon [R6](https://cran.r-project.org/package=R6) for object orientation and [data.table](https://cran.r-project.org/package=data.table) to store and operate on tabular data.\nIn the following subsections, we briefly introduce both packages since at least a basic understanding is required to work efficiently with [mlr3](https://cran.r-project.org/package=mlr3).\n\n## Quick R6 Intro for Beginners {#r6}\n\n[R6](https://cran.r-project.org/package=R6) is one of R's more recent dialects for object-oriented programming (OO).\nIt addresses shortcomings of earlier OO implementations in R, such as S3, which we used in [mlr](https://mlr.mlr-org.com).\nIf you have done any object-oriented programming before, R6 should feel familiar.\nWe focus on the parts of R6 that you need to know to use [mlr3](https://mlr3.mlr-org.com) here.\n\nObjects are created by calling the constructor of an `\"R6::R6Class()\"` object, specifically the initialization method `$new()`.\n  For example, `foo = Foo$new(bar = 1)` creates a new object of class `Foo`, setting the `bar` argument of the constructor to the value `1`.\n  Most objects in [mlr3](https://mlr3.mlr-org.com) are created through special functions (e.g. `lrn(\"regr.rpart\")`) that encapsulate this and are also referred to as *sugar functions*.\n\nObjects have mutable state that is encapsulated in their fields, which can be accessed through the dollar operator.\n  We can access the `bar` value in the `foo` variable from above through `foo$bar` and set its value by assigning the field, e.g. `foo$bar = 2`.\n\nIn addition to fields, objects expose methods that allow to inspect the object's state, retrieve information, or perform an action that changes the internal state of the object.\n  For example, the `$train` method of a learner changes the internal state of the learner by building and storing a trained model, which can then be used to make predictions, given data.\n\nObjects can have public and private fields and methods.\n  The public fields and methods define the API to interact with the object.\n  Private methods are only relevant for you if you want to extend mlr3, e.g. with new learners.\n\nR6 objects are internally environments, and as such have reference semantics.\n  For example, `foo2 = foo` does not create a copy of `foo` in `foo2`, but another reference to the same actual object.\n  Setting `foo$bar = 3` will also change `foo2$bar` to `3` and vice versa.\n\nTo copy an object, use the `$clone()` method and the `deep = TRUE` argument for nested objects, for example, `foo2 = foo$clone(deep = TRUE)`.\n\n:::{.callout-tip}\nFor more details on R6, have a look at the excellent [R6 vignettes](https://r6.r-lib.org/), especially the [introduction](https://r6.r-lib.org/articles/Introduction.html).\n:::\n\n\n## Quick data.table Intro for Beginners {#data.table}\n\nThe package [data.table](https://cran.r-project.org/package=data.table) essentially implements the eponymous alternative to R's `data.frame()`, i.e. an object to store tabular data.\n\n:::{.callout-note}\nWe decided to use `data.table()` because it is blazingly fast and scales quite well on bigger data.\nMany functions of [mlr3](https://mlr3.mlr-org.com) return `data.table`s which can conveniently be subsetted or combined with other outputs.\nIf you happen to not like the syntax or are feeling more comfortable with other tools, base `data.frame`s or [tibble](https://cran.r-project.org/package=tibble)/[dplyr](https://cran.r-project.org/package=dplyr) is just a single `as.data.frame()` or `as_tibble()` away.\n:::\n\nData tables can be constructed using the `data.table()` function (whose interface is similar to `data.frame()`) or by converting an object with `as.data.table()`.\n\n\n::: {.cell hash='intro_cache/html/intro-002.table-001.table-002_5ee83805d450ff04bec8d78fb4d9bdd5'}\n\n```{.r .cell-code}\nlibrary(\"data.table\")\ndf = data.frame(x = 1:12, y = rep(letters[1:3], each = 4))\ndt = as.data.table(df)\n```\n:::\n\n\nAlthough both objects store the data identically in memory, they are considerably different in their operation.\nFirst, the index operator `[` works slightly different.\nFor both objects, the first argument (`i`) is used to select rows and the second argument (`j`) is used to select columns.\nHowever, column names are in the search path, and thus can be used directly:\n\n\n::: {.cell hash='intro_cache/html/intro-003.table-002.table-003_f8a16fb54b51f479475520bfba18e04f'}\n\n```{.r .cell-code}\ndf[df$y == \"a\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 a\n2 2 a\n3 3 a\n4 4 a\n```\n:::\n\n```{.r .cell-code}\ndt[y == \"a\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x y\n1: 1 a\n2: 2 a\n3: 3 a\n4: 4 a\n```\n:::\n:::\n\n\nSecond, there is no optional `drop` argument (`drop` is always `FALSE` for `data.table()`), but instead multiple additional arguments to query the data from the `data.table()` in a very concise way.\nMost importantly, you can group the data with argument `by` and combine this with aggregating functions provided via the second argument (`j`):\n\n\n::: {.cell hash='intro_cache/html/intro-004.table-003.table-004_558d6ece7fb070a1e43b2064315a618b'}\n\n```{.r .cell-code}\ndt[, mean(x), by = \"y\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   y   V1\n1: a  2.5\n2: b  6.5\n3: c 10.5\n```\n:::\n:::\n\n\nThere is also extensive support to perform all kinds of data base join operations (see, e.g., [this RPubs post by Ronald Stalder](https://rstudio-pubs-static.s3.amazonaws.com/52230_5ae0d25125b544caab32f75f0360e775.html)).\n\nFor an in-depth introduction, we refer to the [excellent data.table introduction vignette](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html).\nAlso don't miss the other vignettes linked on the CRAN page of [data.table](https://cran.r-project.org/package=data.table)!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}